{"dataset": "c2rust", "id": "c2rust_0", "problem_id": "p00000", "submission_id": "s113530555", "prompt_id": 1, "messages": [{"role": "user", "content": "You are an expert code translator specializing in converting C functions to Rust functions. You will not answer questions about the code or provide explanations unless explicitly requested. Your sole purpose is to output the translated Rust function.\n\nTranslation Requirements:\n- Direct Output: You must provide only the translated function code without any additional text or explanations.\n- Functional Equivalence: The translated function must maintain identical behavior, semantics, and side effects as the original C function.\n- Function Signature: Carefully translate the function signature:\n  * Convert C types to appropriate Rust types (int → i32, char* → &str or *const i8, etc.)\n  * Use references (&T, &mut T) instead of pointers where possible\n  * Properly handle return types (void → (), error codes → Result<T, E>)\n- Safety-First Approach:\n  * Prefer safe Rust idioms over unsafe blocks whenever possible\n  * Only use `unsafe` when absolutely necessary to maintain equivalence with C behavior\n  * Add safety comments when using unsafe code\n- Modern Rust Practices:\n  * Use Result<T, E> for error handling instead of returning error codes\n  * Use Option<T> for nullable values instead of null pointers\n  * Prefer &str over *const c_char for string parameters when possible\n  * Use Vec<T> instead of raw pointer + length patterns\n  * Apply iterator patterns instead of manual loops where appropriate\n- Memory Management:\n  * Replace malloc/free with Box, Vec, or other RAII types\n  * Ensure proper ownership and lifetime management\n  * Avoid memory leaks by using Rust's ownership system\n- Helper Functions:\n  * If helper functions are needed, define them **inside** the main function as nested functions or closures\n  * Keep the translation self-contained in a single function when possible\n- Naming Conventions:\n  * Use snake_case for function names and variables (following Rust conventions)\n  * If the function name is a Rust reserved keyword, append '_' to the name\n- Dependencies:\n  * Use only the `libc` crate for low-level system calls when necessary\n  * Avoid introducing additional dependencies\n\nOutput Format:\nProvide only the translated Rust function code. Do not wrap it in any tags or markers. Do not include explanations, comments about the translation process, or any text before or after the function code.\n\nTranslate the following C function to safe, idiomatic Rust:\n\n#include<stdio.h>\n\nint main(){\n  int i,j;\n\n  for(i=1;i<10;i++){\n    for(j=1;j<10;j++){\n      printf(\"%dx%d=%d\\n\",i,j,i*j);\n    }\n  }\n\n  return 0;\n}\n"}, {"role": "assistant", "content": "pub fn main() {\n    use libc::{c_int, printf};\n    let mut i: c_int = 1;\n    let mut j: c_int = 1;\n    unsafe {\n        while i < 10 {\n            j = 1;\n            while j < 10 {\n                printf(b\"%dx%d=%d\\n\\0\".as_ptr() as *const _, i, j, i * j);\n                j += 1;\n            }\n            i += 1;\n        }\n    }\n}\n"}]}
{"dataset": "c2rust", "id": "c2rust_1", "problem_id": "p00000", "submission_id": "s911620834", "prompt_id": 2, "messages": [{"role": "user", "content": "You are an expert code translator specializing in converting C functions to Rust functions.\nYour only output must be the translated Rust function code — no explanations, no extra text.\n\nTranslation Rules\n\t1.\tMaintain identical behavior, semantics, and side effects.\n\t2.\tConvert types precisely (int → i32, char* → &str or *const i8, etc.).\n\t3.\tPrefer safe Rust; use unsafe only when strictly necessary, with a safety comment.\n\t4.\tUse idiomatic Rust:\n\t•\tResult<T, E> for error codes\n\t•\tOption<T> for nullable values\n\t•\tVec<T> for pointer + length\n\t•\t&str for strings\n\t5.\tManage memory safely with RAII (Box, Vec); avoid manual allocation/free.\n\t6.\tInline helper logic if needed; keep translation self-contained.\n\t7.\tUse snake_case naming; if a name is a reserved keyword, append _.\n\t8.\tUse only libc for low-level calls when absolutely necessary.\n\nOutput Format\nProvide only the translated Rust function code.\nNow translate the following C function into safe, idiomatic Rust:\n\n#include<stdio.h>\nint main()\n{\n    int i,j;\n    for(i=1; i<10; i++)\n    {\n        for(j=1; j<10; j++)\n            printf(\"%dx%d=%d\\n\", i, j, (i*j));\n    }\n\n    return 0;\n}\n\n"}, {"role": "assistant", "content": "pub fn main() {\n    use libc::printf;\n    let mut i: i32 = 1;\n    let mut j: i32 = 1;\n    while i < 10 {\n        j = 1;\n        while j < 10 {\n            unsafe {\n                printf(b\"%dx%d=%d\\n\\0\".as_ptr() as *const _, i, j, i * j);\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n}\n"}]}
{"dataset": "c2rust", "id": "c2rust_2", "problem_id": "p00001", "submission_id": "s374601710", "prompt_id": 3, "messages": [{"role": "user", "content": "You are a C-to-Rust code translator.\nOutput only the translated Rust function, with no comments or explanations.\n\nRequirements\n\t•\tPreserve full functional equivalence.\n\t•\tConvert types accurately; prefer references and slices over pointers.\n\t•\tUse safe Rust by default; mark unsafe only when required.\n\t•\tReplace manual memory operations with Box or Vec.\n\t•\tUse Result/Option instead of raw error codes or nulls.\n\t•\tFollow Rust naming conventions (snake_case).\n\t•\tAvoid external dependencies except libc if necessary.\n\nTranslate the following C function into idiomatic, safe Rust:\n\n#include <stdio.h> \n\nint main(void) {\n\nint i, j,k,a, tmp; \nint n[10]; \n\n\nfor (k=1; k<=10; k++){ \nscanf(\"%d\", &a);\nn[k]=a;\n} \n\nfor (i=1; i<=10; i++) {\nfor (j=10; j>=i+1; j--) { \n\nif (n[j] > n[j-1]) { \ntmp =  n[j-1]; \nn[j-1] = n[j]; \nn[j] = tmp; \n}\n}\n}\nfor(i=1;i<=3;i++){\nprintf(\"%d\\n\", n[i]);\n}\n\nreturn 0;\n} \n\n"}, {"role": "assistant", "content": "pub fn main() {\n    unsafe {\n        let i: i32 = 0;\n        let j: i32 = 0;\n        let k: i32 = 0;\n        let mut a: i32 = 0;\n        let mut tmp: i32 = 0;\n        let mut n: [i32; 11] = [0; 11];\n        for k in 1..=10 {\n            let a_ptr = &mut a as *mut i32;\n            libc::scanf(b\"%d\\n\\0\".as_ptr() as *const i8, a_ptr);\n            n[k as usize] = a;\n        }\n        for i in 1..=10 {\n            for j in ((i + 1)..=10).rev() {\n                let j_idx = j as usize;\n                let j_minus_1_idx = j_idx - 1;\n                if n[j_idx] > n[j_minus_1_idx] {\n                    tmp = n[j_minus_1_idx];\n                    n[j_minus_1_idx] = n[j_idx];\n                    n[j_idx] = tmp;\n                }\n            }\n        }\n        for i in 1..=3 {\n            let n_i = n[i as usize];\n            libc::printf(b\"%d\\n\\0\".as_ptr() as *const i8, n_i);\n        }\n    }\n}\n"}]}
{"dataset": "c2rust", "id": "c2rust_3", "problem_id": "p00001", "submission_id": "s439449315", "prompt_id": 4, "messages": [{"role": "user", "content": "Translate the given C function into safe, idiomatic Rust.\nOutput only the Rust function code — no explanations.\n\nRules:\n\t•\tMaintain equivalent logic and side effects.\n\t•\tPrefer safe Rust; use unsafe only when required.\n\t•\tUse Result/Option, &str, Vec, and RAII memory management.\n\t•\tFollow Rust conventions (snake_case, no extra dependencies).\n\nTranslate the C function below:\n\n#include <stdio.h>\nint main(){\n    int n;\n    int a,b,c;\n    \n    a=b=c=0;\n    \n    for(int i=0;i<10;i++){\n        scanf(\"%d\",&n);\n        if(n>=a){\n            c=b;b=a;a=n;\n        }else if(n>=b){\n            c=b,b=n;\n        }else if(n>c){\n            c=n;\n        }\n    }\n    printf(\"%d\\n%d\\n%d\\n\",a,b,c);\n    \n    return(0);\n    \n}\n\n"}, {"role": "assistant", "content": "pub fn main() {\n    use std::io::{self, Read};\n    let mut input = String::new();\n    io::stdin()\n        .read_to_string(&mut input)\n        .expect(\"Failed to read input\");\n    let mut numbers = input\n        .split_whitespace()\n        .map(|s| s.parse::<i32>().expect(\"Invalid number\"));\n    let mut a = i32::MIN;\n    let mut b = i32::MIN;\n    let mut c = i32::MIN;\n    for _ in 0..10 {\n        let n = numbers.next().expect(\"Not enough numbers provided\");\n        if n >= a {\n            c = b;\n            b = a;\n            a = n;\n        } else if n >= b {\n            c = b;\n            b = n;\n        } else if n > c {\n            c = n;\n        }\n    }\n    println!(\"{}\\n{}\\n{}\", a, b, c);\n}\n"}]}
{"dataset": "c2rust", "id": "c2rust_4", "problem_id": "p00003", "submission_id": "s675069470", "prompt_id": 5, "messages": [{"role": "user", "content": "You are a professional code conversion specialist whose task is to translate C functions into idiomatic Rust functions.\nDo not provide explanations, reasoning, or commentary unless explicitly asked.\nYour sole objective is to produce the translated Rust function that mirrors the original C function’s logic and behavior.\n\nGuidelines for Translation\n\t•\tOutput Policy:\nOnly output the translated Rust function code. Do not include comments, markdown formatting, or descriptive text.\n\t•\tFunctional Fidelity:\nThe Rust translation must preserve every semantic detail, side effect, and return behavior of the C function.\n\t•\tFunction Signature Conversion:\n\t•\tMap C types to their Rust counterparts (e.g., int → i32, char* → &str or *const i8, etc.).\n\t•\tReplace raw pointers with references (&T, &mut T) wherever possible.\n\t•\tAdjust the return type appropriately (void → (), error codes → Result<T, E>).\n\t•\tSafety and Reliability:\n\t•\tDefault to safe Rust.\n\t•\tUse unsafe blocks only when equivalence demands it, and add a short safety note inside.\n\t•\tAvoid unnecessary low-level memory manipulation.\n\t•\tRust Idioms:\n\t•\tUse Result for error handling and Option for nullable values.\n\t•\tRepresent C-style arrays or buffers using Vec<T>.\n\t•\tPrefer &str instead of *const c_char for strings when possible.\n\t•\tReplace manual loops with iterators or high-level constructs when it does not alter semantics.\n\t•\tMemory Management:\n\t•\tSubstitute malloc / free calls with Rust’s managed types (Box, Vec, etc.).\n\t•\tGuarantee proper ownership, lifetime, and deallocation through Rust’s RAII mechanism.\n\t•\tEnsure no memory leaks or dangling references occur.\n\t•\tHelper Logic:\n\t•\tIf helper routines are required, define them within the function body as closures or nested functions.\n\t•\tKeep the translation self-contained.\n\t•\tNaming Rules:\n\t•\tFollow Rust naming conventions (snake_case).\n\t•\tIf the C function name conflicts with a Rust keyword, append an underscore.\n\t•\tDependencies:\n\t•\tUse only the libc crate for low-level operations when absolutely necessary.\n\t•\tAvoid adding any third-party dependencies.\n\nExpected Output\n\nProduce only the translated Rust function — with no prefix, suffix, or explanation.\nNow translate the following C function into safe, idiomatic Rust:\n\n#include <stdio.h>\nint main(){\n    int a,b,c,temp,i,j;\n    \n    scanf(\"%d\",&i);\n    for(j=0;j<i;j++){\n        scanf(\"%d %d %d\",&a,&b,&c);\n        \n        if(a>b){\n            temp=a;a=b;b=temp;\n        }if(b>c){\n            temp=b;b=c;c=temp;\n        }if(a>b){\n            temp=a;a=b;b=temp;\n        }\n        \n        if(a*a+b*b==c*c){\n            printf(\"YES\\n\");\n        }else{\n            printf(\"NO\\n\");\n        }\n    }\n    return(0);\n}\n"}, {"role": "assistant", "content": "pub fn main() {\n    \n    use std::ffi::CString;\n    use std::io::{self, Write};\n    let mut a: i32 = 0;\n    let mut b: i32 = 0;\n    let mut c: i32 = 0;\n    let mut temp: i32 = 0;\n    let mut i: i32 = 0;\n    let j: i32 = 0;\n    unsafe {\n        let _ = io::stdout().flush();\n        let format_str_i = CString::new(\"%d\\n\").expect(\"CString::new failed\");\n        let format_str_abc = CString::new(\"%d %d %d\\n\").expect(\"CString::new failed\");\n        let _ = libc::scanf(format_str_i.as_ptr(), &mut i as *mut i32);\n        for j in 0..i {\n            let _ = libc::scanf(\n                format_str_abc.as_ptr(),\n                &mut a as *mut i32,\n                &mut b as *mut i32,\n                &mut c as *mut i32,\n            );\n            if a > b {\n                temp = a;\n                a = b;\n                b = temp;\n            }\n            if b > c {\n                temp = b;\n                b = c;\n                c = temp;\n            }\n            if a > b {\n                temp = a;\n                a = b;\n                b = temp;\n            }\n            if a * a + b * b == c * c {\n                let _ = io::Write::write_all(&mut io::stdout(), b\"YES\\n\");\n            } else {\n                let _ = io::Write::write_all(&mut io::stdout(), b\"NO\\n\");\n            }\n        }\n    }\n}\n"}]}
{"dataset": "c2rust", "id": "c2rust_5", "problem_id": "p00003", "submission_id": "s026223911", "prompt_id": 1, "messages": [{"role": "user", "content": "You are an expert code translator specializing in converting C functions to Rust functions. You will not answer questions about the code or provide explanations unless explicitly requested. Your sole purpose is to output the translated Rust function.\n\nTranslation Requirements:\n- Direct Output: You must provide only the translated function code without any additional text or explanations.\n- Functional Equivalence: The translated function must maintain identical behavior, semantics, and side effects as the original C function.\n- Function Signature: Carefully translate the function signature:\n  * Convert C types to appropriate Rust types (int → i32, char* → &str or *const i8, etc.)\n  * Use references (&T, &mut T) instead of pointers where possible\n  * Properly handle return types (void → (), error codes → Result<T, E>)\n- Safety-First Approach:\n  * Prefer safe Rust idioms over unsafe blocks whenever possible\n  * Only use `unsafe` when absolutely necessary to maintain equivalence with C behavior\n  * Add safety comments when using unsafe code\n- Modern Rust Practices:\n  * Use Result<T, E> for error handling instead of returning error codes\n  * Use Option<T> for nullable values instead of null pointers\n  * Prefer &str over *const c_char for string parameters when possible\n  * Use Vec<T> instead of raw pointer + length patterns\n  * Apply iterator patterns instead of manual loops where appropriate\n- Memory Management:\n  * Replace malloc/free with Box, Vec, or other RAII types\n  * Ensure proper ownership and lifetime management\n  * Avoid memory leaks by using Rust's ownership system\n- Helper Functions:\n  * If helper functions are needed, define them **inside** the main function as nested functions or closures\n  * Keep the translation self-contained in a single function when possible\n- Naming Conventions:\n  * Use snake_case for function names and variables (following Rust conventions)\n  * If the function name is a Rust reserved keyword, append '_' to the name\n- Dependencies:\n  * Use only the `libc` crate for low-level system calls when necessary\n  * Avoid introducing additional dependencies\n\nOutput Format:\nProvide only the translated Rust function code. Do not wrap it in any tags or markers. Do not include explanations, comments about the translation process, or any text before or after the function code.\n\nTranslate the following C function to safe, idiomatic Rust:\n\n#include<stdio.h>\n\nvoid swapc(int*, int*);\n\nint main(){\n  int a,b,c,n,i;\n\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%d %d %d\",&a,&b,&c);\n    swapc(&a,&c);\n    swapc(&b,&c);\n    if(a*a+b*b == c*c){\n      printf(\"YES\\n\");\n    }\n    else {\n      printf(\"NO\\n\");\n    }\n  }\n  return 0;\n}\n\nvoid swapc(int *x, int *c){\n  int temp;\n  if(*x>*c){\n    temp = *x;\n    *x = *c;\n    *c = temp;\n  }\n}\n"}, {"role": "assistant", "content": "pub fn main() {\n    let mut a: i32 = 0;\n    let mut b: i32 = 0;\n    let mut c: i32 = 0;\n    let mut n: i32 = 0;\n    let i: i32 = 0;\n    unsafe {\n        libc::scanf(b\"%d\\0\" as *const u8 as *const libc::c_char, &mut n);\n        for i in 0..n {\n            libc::scanf(\n                b\"%d %d %d\\0\" as *const u8 as *const libc::c_char,\n                &mut a,\n                &mut b,\n                &mut c,\n            );\n            swapc(&mut a, &mut c);\n            swapc(&mut b, &mut c);\n            if a * a + b * b == c * c {\n                libc::printf(b\"YES\\n\\0\" as *const u8 as *const libc::c_char);\n            } else {\n                libc::printf(b\"NO\\n\\0\" as *const u8 as *const libc::c_char);\n            }\n        }\n    }\n}\npub fn swapc(x: *mut i32, c: *mut i32) {\n    unsafe {\n        let temp;\n        if *x > *c {\n            temp = *x;\n            *x = *c;\n            *c = temp;\n        }\n    }\n}\n"}]}
{"dataset": "c2rust", "id": "c2rust_6", "problem_id": "p00004", "submission_id": "s002492070", "prompt_id": 2, "messages": [{"role": "user", "content": "You are an expert code translator specializing in converting C functions to Rust functions.\nYour only output must be the translated Rust function code — no explanations, no extra text.\n\nTranslation Rules\n\t1.\tMaintain identical behavior, semantics, and side effects.\n\t2.\tConvert types precisely (int → i32, char* → &str or *const i8, etc.).\n\t3.\tPrefer safe Rust; use unsafe only when strictly necessary, with a safety comment.\n\t4.\tUse idiomatic Rust:\n\t•\tResult<T, E> for error codes\n\t•\tOption<T> for nullable values\n\t•\tVec<T> for pointer + length\n\t•\t&str for strings\n\t5.\tManage memory safely with RAII (Box, Vec); avoid manual allocation/free.\n\t6.\tInline helper logic if needed; keep translation self-contained.\n\t7.\tUse snake_case naming; if a name is a reserved keyword, append _.\n\t8.\tUse only libc for low-level calls when absolutely necessary.\n\nOutput Format\nProvide only the translated Rust function code.\nNow translate the following C function into safe, idiomatic Rust:\n\n#include <stdio.h>\n#include <math.h>\nint main(void){\n    double a,b,c,d,e,f,aa,bb,cc,x,y,bai;\n    while(scanf(\"%lf %lf %lf %lf %lf %lf\",&a,&b,&c,&d,&e,&f)!=EOF){\n        bai=d/a;\n        aa=a*bai;\n        bb=b*bai;\n        cc=c*bai;\n        y=(f-cc)/(e-bb);\n        x=(c-b*y)/a;\n        printf(\"%.3f %.3f\\n\",x,y);\n    }\n        \n        \n        \n        \n    \n    \n    \n}\n"}, {"role": "assistant", "content": "use libc::printf;\nuse libc::scanf;\nuse std::ffi::CString;\npub fn main() {\n    unsafe {\n        let mut a: f64 = 0.0;\n        let mut b: f64 = 0.0;\n        let mut c: f64 = 0.0;\n        let mut d: f64 = 0.0;\n        let mut e: f64 = 0.0;\n        let mut f: f64 = 0.0;\n        loop {\n            let format_str = CString::new(\"%lf %lf %lf %lf %lf %lf\").unwrap();\n            let result = scanf(\n                format_str.as_ptr(),\n                &mut a,\n                &mut b,\n                &mut c,\n                &mut d,\n                &mut e,\n                &mut f,\n            );\n            if result != 6 {\n                break;\n            }\n            let bai = d / a;\n            let aa = a * bai;\n            let bb = b * bai;\n            let cc = c * bai;\n            let y = (f - cc) / (e - bb);\n            let x = (c - b * y) / a;\n            let output_format = CString::new(\"%.3f %.3f\\n\").unwrap();\n            printf(output_format.as_ptr(), x, y);\n        }\n    }\n}\n"}]}
{"dataset": "c2rust", "id": "c2rust_7", "problem_id": "p00004", "submission_id": "s625410104", "prompt_id": 3, "messages": [{"role": "user", "content": "You are a C-to-Rust code translator.\nOutput only the translated Rust function, with no comments or explanations.\n\nRequirements\n\t•\tPreserve full functional equivalence.\n\t•\tConvert types accurately; prefer references and slices over pointers.\n\t•\tUse safe Rust by default; mark unsafe only when required.\n\t•\tReplace manual memory operations with Box or Vec.\n\t•\tUse Result/Option instead of raw error codes or nulls.\n\t•\tFollow Rust naming conventions (snake_case).\n\t•\tAvoid external dependencies except libc if necessary.\n\nTranslate the following C function into idiomatic, safe Rust:\n\n#include<stdio.h>\n\nvoid zero(double*);\n\nint main(){\n  int a,b,c,d,e,f;\n  double x,y;\n\n  while(scanf(\"%d %d %d %d %d %d\",&a,&b,&c,&d,&e,&f) != EOF){\n    x = (double)(c*e-b*f)/(double)(a*e-d*b);\n    y = ((double)c-(double)a*x)/(double)b;\n    zero(&x);\n    zero(&y);\n    printf(\"%.3f %.3f\\n\",x,y);\n  }\n\n  return 0;\n}\n\nvoid zero(double *x){\n  if(*x == 0.0){\n    *x = 0.0;\n  }\n}\n\n"}, {"role": "assistant", "content": "pub fn main() {\n    unsafe {\n        let mut a: libc::c_int = 0;\n        let mut b: libc::c_int = 0;\n        let mut c: libc::c_int = 0;\n        let mut d: libc::c_int = 0;\n        let mut e: libc::c_int = 0;\n        let mut f: libc::c_int = 0;\n        while libc::scanf(\n            b\"%d %d %d %d %d %d\\0\".as_ptr() as *const libc::c_char,\n            &mut a,\n            &mut b,\n            &mut c,\n            &mut d,\n            &mut e,\n            &mut f,\n        ) != libc::EOF\n        {\n            let x_val = (c as f64 * e as f64 - b as f64 * f as f64)\n                / (a as f64 * e as f64 - d as f64 * b as f64);\n            let y_val = (c as f64 - a as f64 * x_val) / b as f64;\n            let mut x = x_val;\n            let mut y = y_val;\n            zero(&mut x as *mut f64 as *mut libc::c_double);\n            zero(&mut y as *mut f64 as *mut libc::c_double);\n            libc::printf(b\"%.3f %.3f\\n\\0\".as_ptr() as *const libc::c_char, x, y);\n        }\n    }\n}\npub unsafe fn zero(x: *mut libc::c_double) {\n    if *x == 0.0 {\n        *x = 0.0;\n    }\n}\n"}]}
{"dataset": "c2rust", "id": "c2rust_8", "problem_id": "p00005", "submission_id": "s074479201", "prompt_id": 4, "messages": [{"role": "user", "content": "Translate the given C function into safe, idiomatic Rust.\nOutput only the Rust function code — no explanations.\n\nRules:\n\t•\tMaintain equivalent logic and side effects.\n\t•\tPrefer safe Rust; use unsafe only when required.\n\t•\tUse Result/Option, &str, Vec, and RAII memory management.\n\t•\tFollow Rust conventions (snake_case, no extra dependencies).\n\nTranslate the C function below:\n\n#include<stdio.h>\n\nlong int LCM(long int, long int);\nvoid swap(long int*, long int*);\n\nint main(){\n  long int a,b;\n  long int lcm,gcd;\n\n  while(scanf(\"%ld %ld\",&a,&b) != EOF){\n    swap(&a,&b);\n    lcm = LCM(a,b);\n    gcd = a/lcm*b;\n    printf(\"%ld %ld\\n\",lcm,gcd);\n  }\n  return 0;\n}\n\nlong int LCM(long int a, long int b){\n  int r;\n  if (b==0){\n    return a;\n  }\n  else {\n    r = a % b;\n    return LCM(b,r);\n  }\n}\n\nvoid swap(long int *x, long int *y){\n  long int temp;\n  if(*x<*y){\n    temp = *x;\n    *x = *y;\n    *y = temp;\n  }\n}\n"}, {"role": "assistant", "content": "use libc::c_int;\nuse libc::c_long;\npub fn main() {\n    let mut a: i64 = 0;\n    let mut b: i64 = 0;\n    let mut lcm: i64 = 0;\n    let mut gcd: i64 = 0;\n    unsafe {\n        let format_scanf = std::ffi::CString::new(\"%ld %ld\").unwrap();\n        let format_printf = std::ffi::CString::new(\"%ld %ld\\n\").unwrap();\n        while libc::scanf(\n            format_scanf.as_ptr(),\n            &mut a as *mut i64,\n            &mut b as *mut i64,\n        ) != libc::EOF\n        {\n            swap(&mut a, &mut b);\n            lcm = LCM(a, b);\n            gcd = a / lcm * b;\n            libc::printf(format_printf.as_ptr(), lcm, gcd);\n        }\n    }\n}\npub fn LCM(a: c_long, b: c_long) -> c_long {\n    unsafe {\n        if b == 0 {\n            a\n        } else {\n            let r: c_int = (a % b) as c_int;\n            LCM(b, r as c_long)\n        }\n    }\n}\npub fn swap(x: *mut i64, y: *mut i64) {\n    unsafe {\n        let temp = *x;\n        if temp < *y {\n            *x = *y;\n            *y = temp;\n        }\n    }\n}\n"}]}
{"dataset": "c2rust", "id": "c2rust_9", "problem_id": "p00005", "submission_id": "s393960000", "prompt_id": 5, "messages": [{"role": "user", "content": "You are a professional code conversion specialist whose task is to translate C functions into idiomatic Rust functions.\nDo not provide explanations, reasoning, or commentary unless explicitly asked.\nYour sole objective is to produce the translated Rust function that mirrors the original C function’s logic and behavior.\n\nGuidelines for Translation\n\t•\tOutput Policy:\nOnly output the translated Rust function code. Do not include comments, markdown formatting, or descriptive text.\n\t•\tFunctional Fidelity:\nThe Rust translation must preserve every semantic detail, side effect, and return behavior of the C function.\n\t•\tFunction Signature Conversion:\n\t•\tMap C types to their Rust counterparts (e.g., int → i32, char* → &str or *const i8, etc.).\n\t•\tReplace raw pointers with references (&T, &mut T) wherever possible.\n\t•\tAdjust the return type appropriately (void → (), error codes → Result<T, E>).\n\t•\tSafety and Reliability:\n\t•\tDefault to safe Rust.\n\t•\tUse unsafe blocks only when equivalence demands it, and add a short safety note inside.\n\t•\tAvoid unnecessary low-level memory manipulation.\n\t•\tRust Idioms:\n\t•\tUse Result for error handling and Option for nullable values.\n\t•\tRepresent C-style arrays or buffers using Vec<T>.\n\t•\tPrefer &str instead of *const c_char for strings when possible.\n\t•\tReplace manual loops with iterators or high-level constructs when it does not alter semantics.\n\t•\tMemory Management:\n\t•\tSubstitute malloc / free calls with Rust’s managed types (Box, Vec, etc.).\n\t•\tGuarantee proper ownership, lifetime, and deallocation through Rust’s RAII mechanism.\n\t•\tEnsure no memory leaks or dangling references occur.\n\t•\tHelper Logic:\n\t•\tIf helper routines are required, define them within the function body as closures or nested functions.\n\t•\tKeep the translation self-contained.\n\t•\tNaming Rules:\n\t•\tFollow Rust naming conventions (snake_case).\n\t•\tIf the C function name conflicts with a Rust keyword, append an underscore.\n\t•\tDependencies:\n\t•\tUse only the libc crate for low-level operations when absolutely necessary.\n\t•\tAvoid adding any third-party dependencies.\n\nExpected Output\n\nProduce only the translated Rust function — with no prefix, suffix, or explanation.\nNow translate the following C function into safe, idiomatic Rust:\n\n#include<stdio.h>\nint main(){\n\tlong long n,k,a,b,x,y,z;\n\twhile(scanf(\"%lld %lld\",&n,&k)!=EOF){\n\t\tif(n<k){a=n;b=k;}\n\t\telse{a=k;b=n;}\n\t\tx=b%a;\n\t\twhile(x!=0){\n\t\t\tb=a;\n\t\t\ta=x;\n\t\t\tx=b%a;\n\t\t}\n\t\tx=a;\n\t\tprintf(\"%lld %lld\\n\",x,n*k/x);\n\t}\n\treturn 0;\n}\n\n"}, {"role": "assistant", "content": "pub fn main() {\n    use libc::{printf, scanf};\n    let mut n: i64 = 0;\n    let mut k: i64 = 0;\n    unsafe {\n        while scanf(\n            b\"%lld %lld\\0\".as_ptr() as *const _,\n            &mut n as *mut _,\n            &mut k as *mut _,\n        ) != -1\n        {\n            let (mut a, mut b) = if n < k { (n, k) } else { (k, n) };\n            let mut x = b % a;\n            while x != 0 {\n                b = a;\n                a = x;\n                x = b % a;\n            }\n            let x = a;\n            let result = n * k / x;\n            let _ = printf(b\"%lld %lld\\n\\0\".as_ptr() as *const _, x, result);\n        }\n    }\n}\n"}]}
